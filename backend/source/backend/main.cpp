#include <backend/main.hpp>

#include <backend/process/process_store.hpp>

#include <nui/core.hpp>
#include <nui/rpc.hpp>
#include <nui/window.hpp>
#include <roar/mime_type.hpp>
#include <efsw/efsw.hpp>
#include <log/log.hpp>
#include <libssh/libsshpp.hpp>

// This file is generated by nui.
#include <index.hpp>

#include <iostream>
#include <filesystem>
#include <fstream>
#include <string>
#include <string_view>
#include <unordered_map>
#include <iostream>

#ifdef __linux__
#    include <signal.h>
#endif

using namespace std::string_literals;
using namespace std::chrono_literals;
using namespace Nui;

#ifdef __linux__
volatile sig_atomic_t sigchld[10] = {0};
#endif

namespace
{
    auto makeResponse(int code, std::string const& reason, std::string body, std::string const& mimeType = ""s)
    {
        std::unordered_multimap<std::string, std::string> headers = {
            {"Content-Type"s, mimeType.empty() ? "text/plain" : mimeType},
            // Do not forget to allow CORS
            {"Access-Control-Allow-Origin"s, "*"s},
        };

        if (!body.empty())
            headers.emplace("Content-Length"s, std::to_string(body.size()));

        return CustomSchemeResponse{
            .statusCode = code,
            .reasonPhrase = reason,
            .headers = std::move(headers),
            .body = std::move(body),
        };
    };

    auto readFile(std::filesystem::path const& path)
    {
        std::ifstream reader{path, std::ios::binary};
        reader.seekg(0, std::ios::end);
        std::string content(reader.tellg(), '\0');
        reader.seekg(0, std::ios::beg);
        reader.read(&content[0], content.size());
        return content;
    };

    CustomScheme createFolderMapping(std::filesystem::path const& programDir, std::string const& schemeName)
    {
        return CustomScheme{
            .scheme = schemeName,
            .allowedOrigins = {"*"s},
            .onRequest =
                [programDir, schemeName](CustomSchemeRequest const& request) {
                    // make path relative to / to avoid directory traversal
                    const auto url = request.parseUrl();
                    if (!url)
                    {
                        Log::error("Failed to parse url: '{}'", request.uri);
                        return makeResponse(400, "Bad Request", "Bad Request");
                    }

                    const auto pathString = url->pathAsString();
                    Log::debug("Request for {}", pathString);

                    if (pathString == "/index.html")
                        return makeResponse(200, "OK", index(), "text/html");

                    const auto file = [&]() {
                        const auto endsWith = [&](std::string_view ending) {
                            return pathString.size() >= ending.size() &&
                                pathString.substr(pathString.size() - ending.size()) == ending;
                        };

                        if (endsWith("css_variables.css"))
                        {
                            return programDir / "themes" / std::filesystem::path{pathString}.parent_path().filename() /
                                "css_variables.css";
                        }

                        // make path relative to / to avoid directory traversal
                        if (endsWith(".js") || endsWith(".map") || endsWith(".css") || endsWith(".ttf"))
                            return programDir / "dynamic_sources" / std::filesystem::relative(pathString, "/");
                        else
                            return programDir / "assets" / std::filesystem::relative(pathString, "/");
                    }();

                    // Check if file exists and return 404 if not
                    if (!std::filesystem::exists(file))
                    {
                        Log::error("File not found: '{}'", file.string());
                        return CustomSchemeResponse{
                            .statusCode = 404,
                            .reasonPhrase = "Not Found",
                            .headers =
                                {
                                    {"Content-Type"s, "text/plain"s},
                                    // Do not forget to allow CORS
                                    {"Access-Control-Allow-Origin"s, "*"s},
                                },
                            .body = "Not Found: "s + file.string(),
                        };
                    }

                    Log::debug("Serving file: '{}'", file.string());

                    // Read file
                    auto content = readFile(file);

                    // Return file
                    const auto code = content.empty() ? 204 : 200;
                    return makeResponse(
                        code,
                        "OK",
                        std::move(content),
                        Roar::extensionToMime(file.extension().string()).value_or("application/octet-stream"));
                },

            // Windows: Is this secure like https (not http)? A lot of things are not allowed in http.
            .treatAsSecure = true,

            // Windows: Do urls to this custom scheme have an authority component? (For portability reasons, they
            // usually should have).
            .hasAuthorityComponent = true,
        };
    }
}

Main::Main(int const, char const* const* argv)
    : programDir_{std::filesystem::path{argv[0]}.parent_path()}
    , stateHolder_{}
    , window_{
          Nui::WindowOptions{
              .title = "NuiScp"s,
              .debug = true,
              .customSchemes = {createFolderMapping(programDir_, "nui")},
          },
      }
    , hub_{window_}
    , processes_{window_.getExecutor(), window_, hub_}
    , prompter_{hub_}
    , sshSessionManager_{std::make_shared<SshSessionManager>(window_.getExecutor(), &stateHolder_)}
    , shuttingDown_{false}
    , childSignalTimer_{window_.getExecutor()}
{
    sshSessionManager_->addPasswordProvider(-99, &prompter_);

    stateHolder_.load([](bool success, Persistence::StateHolder& holder) {
        if (!success)
            return;

        Log::setLevel(holder.stateCache().logLevel);
    });
}
Main::~Main()
{
    shuttingDown_ = true;
    sshSessionManager_->stopUpdateDispatching();
    childSignalTimer_.cancel();
}

void Main::registerRpc()
{
    hub_.enableFetch();
    hub_.enableTimer();
    hub_.enableWindowFunctions();
    hub_.enableEnvironmentVariables();
    hub_.enableThrottle();
    hub_.enableFileDialogs();

    Log::setupBackendRpcHub(&hub_);
    stateHolder_.registerRpc(hub_);
    processes_.registerRpc(window_, hub_);
    sshSessionManager_->registerRpc(window_, hub_);
}

void Main::show()
{
    window_.setSize(1600, 900, Nui::WebViewHint::WEBVIEW_HINT_NONE);
    window_.centerOnPrimaryDisplay();
    // window_.setHtml(index());
    window_.navigate("nui://app.example/index.html");
    window_.setConsoleOutput(false);
    window_.run();
}

void Main::startChildSignalTimer()
{
    if (shuttingDown_)
        return;

#ifdef __linux__
    childSignalTimer_.expires_after(200ms);
    childSignalTimer_.async_wait([this](boost::system::error_code const& ec) {
        if (ec)
            return;

        for (auto& i : sigchld)
        {
            if (i > 0)
            {
                window_.runInJavascriptThread([i, this]() {
                    processes_.notifyChildExit(hub_, i);
                });
                i = 0;
            }
        }

        startChildSignalTimer();
    });
#endif
}

int main(int const argc, char const* const* argv)
{
#ifdef __linux__
#    pragma clang diagnostic push
#    pragma clang diagnostic ignored "-Wc99-designator"
    struct sigaction sa{
        .sa_sigaction =
            +[](int, siginfo_t* info, void*) {
                const pid_t pid = info->si_pid;
                if (pid > 0)
                {
                    for (auto& i : sigchld)
                    {
                        if (i == 0)
                        {
                            i = pid;
                            break;
                        }
                    }
                }
            },
        .sa_mask = {},
        .sa_flags = SA_SIGINFO,
        .sa_restorer = nullptr,
    };

    sigaction(SIGCHLD, &sa, nullptr);
#    pragma clang diagnostic pop
#endif

    ssh_init();

    {
        Main m{argc, argv};
        m.registerRpc();
        m.startChildSignalTimer();
        m.show();
    }

    ssh_finalize();
}