#include <backend/main.hpp>

#include <backend/process/process_store.hpp>

#ifndef __WIN32
#    include <boost/process/v2/src.hpp>
#endif

#include <nui/core.hpp>
#include <nui/rpc.hpp>
#include <nui/window.hpp>
#include <roar/mime_type.hpp>
#include <efsw/efsw.hpp>
#include <log/log.hpp>

// This file is generated by nui.
#include <index.hpp>

#include <iostream>
#include <filesystem>
#include <fstream>
#include <string>
#include <string_view>
#include <memory>

using namespace std::string_literals;
using namespace std::chrono_literals;
using namespace Nui;

namespace
{
    CustomScheme createFolderMapping(std::filesystem::path const& programDir, std::string const& schemeName)
    {
        return CustomScheme{
            .scheme = schemeName,
            .allowedOrigins = {"*"s},
            .onRequest =
                [programDir, schemeName](CustomSchemeRequest const& request) {
                    // make path relative to / to avoid directory traversal
                    const auto file =
                        programDir / schemeName / std::filesystem::relative(request.parseUrl()->pathAsString(), "/");

                    // Check if file exists and return 404 if not
                    if (!std::filesystem::exists(file))
                    {
                        return CustomSchemeResponse{
                            .statusCode = 404,
                            .reasonPhrase = "Not Found",
                            .headers =
                                {
                                    {"Content-Type"s, "text/plain"s},
                                    // Do not forget to allow CORS
                                    {"Access-Control-Allow-Origin"s, "*"s},
                                },
                            .body = "Not Found: "s + file.string(),
                        };
                    }

                    // Read file
                    std::ifstream reader{file, std::ios::binary};
                    if (!reader.is_open())
                    {
                        return CustomSchemeResponse{
                            .statusCode = 500,
                            .reasonPhrase = "Internal Server Error",
                            .headers =
                                {
                                    {"Content-Type"s, "text/plain"s},
                                    // Do not forget to allow CORS
                                    {"Access-Control-Allow-Origin"s, "*"s},
                                },
                            .body = "Internal Server Error",
                        };
                    }

                    reader.seekg(0, std::ios::end);
                    std::string content(reader.tellg(), '\0');
                    reader.seekg(0, std::ios::beg);
                    reader.read(&content[0], content.size());

                    // Get mime type
                    const std::string mime =
                        Roar::extensionToMime(file.extension().string()).value_or("application/octet-stream");

                    // Return file
                    return CustomSchemeResponse{
                        .statusCode = content.empty() ? 204 : 200,
                        .reasonPhrase = "OK",
                        .headers =
                            {
                                {"Content-Type"s, mime},
                                // Do not forget to allow CORS
                                {"Access-Control-Allow-Origin"s, "*"s},
                            },

                        // Currently there is no streaming way to write the body, if its large.
                        .body = content,
                    };
                },

            // Windows: Is this secure like https (not http)? A lot of things are not allowed in http.
            .treatAsSecure = true,

            // Windows: Do urls to this custom scheme have an authority component? (For portability reasons, they
            // usually should have).
            .hasAuthorityComponent = true,
        };
    }
}

Main::Main(int const, char const* const* argv)
    : programDir_{std::filesystem::path{argv[0]}.parent_path()}
    , stateHolder_{}
    , window_{
          Nui::WindowOptions{
              .title = "NuiScp"s,
              .debug = true,
              .customSchemes = {createFolderMapping(programDir_, "liveload"), createFolderMapping(programDir_, "assets")},
          },
      }
    , hub_{window_}
    , processes_{window_.getExecutor()}
{
    stateHolder_.initializeOsDefaults();
}
Main::~Main() = default;

void Main::registerRpc()
{
    hub_.enableFetch();
    hub_.enableTimer();
    hub_.enableWindowFunctions();
    hub_.enableEnvironmentVariables();
    hub_.enableThrottle();
    hub_.enableFileDialogs();

    Log::setupBackendRpcHub(&hub_);
    stateHolder_.registerRpc(hub_);
    processes_.registerRpc(window_, hub_);
}

void Main::show()
{
    window_.setSize(1200, 800, Nui::WebViewHint::WEBVIEW_HINT_NONE);
    window_.centerOnPrimaryDisplay();
    window_.setHtml(index());
    window_.setConsoleOutput(false);
    window_.run();
}

int main(int const argc, char const* const* argv)
{
    Main m{argc, argv};
    m.registerRpc();
    m.show();
}