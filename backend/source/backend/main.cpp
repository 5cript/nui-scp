#include <backend/process/process_store.hpp>

#include <nui/core.hpp>
#include <nui/rpc.hpp>
#include <nui/window.hpp>
#include <roar/mime_type.hpp>
#include <efsw/efsw.hpp>

// This file is generated by nui.
#include <index.hpp>

#include <iostream>
#include <filesystem>
#include <fstream>
#include <string>
#include <string_view>
#include <memory>

using namespace std::string_literals;
using namespace std::chrono_literals;
using namespace Nui;

CustomScheme createFolderMapping(std::filesystem::path const& programDir, std::string const& schemeName)
{
    return CustomScheme{
        .scheme = schemeName,
        .allowedOrigins = {"*"s},
        .onRequest =
            [programDir, schemeName](CustomSchemeRequest const& request) {
                // make path relative to / to avoid directory traversal
                const auto file =
                    programDir / schemeName / std::filesystem::relative(request.parseUrl()->pathAsString(), "/");

                // Check if file exists and return 404 if not
                if (!std::filesystem::exists(file))
                {
                    return CustomSchemeResponse{
                        .statusCode = 404,
                        .reasonPhrase = "Not Found",
                        .headers =
                            {
                                {"Content-Type"s, "text/plain"s},
                                // Do not forget to allow CORS
                                {"Access-Control-Allow-Origin"s, "*"s},
                            },
                        .body = "Not Found: "s + file.string(),
                    };
                }

                // Read file
                std::ifstream reader{file, std::ios::binary};
                if (!reader.is_open())
                {
                    return CustomSchemeResponse{
                        .statusCode = 500,
                        .reasonPhrase = "Internal Server Error",
                        .headers =
                            {
                                {"Content-Type"s, "text/plain"s},
                                // Do not forget to allow CORS
                                {"Access-Control-Allow-Origin"s, "*"s},
                            },
                        .body = "Internal Server Error",
                    };
                }

                reader.seekg(0, std::ios::end);
                std::string content(reader.tellg(), '\0');
                reader.seekg(0, std::ios::beg);
                reader.read(&content[0], content.size());

                // Get mime type
                const std::string mime =
                    Roar::extensionToMime(file.extension().string()).value_or("application/octet-stream");

                // Return file
                return CustomSchemeResponse{
                    .statusCode = content.empty() ? 204 : 200,
                    .reasonPhrase = "OK",
                    .headers =
                        {
                            {"Content-Type"s, mime},
                            // Do not forget to allow CORS
                            {"Access-Control-Allow-Origin"s, "*"s},
                        },

                    // Currently there is no streaming way to write the body, if its large.
                    .body = content,
                };
            },

        // Windows: Is this secure like https (not http)? A lot of things are not allowed in http.
        .treatAsSecure = true,

        // Windows: Do urls to this custom scheme have an authority component? (For portability reasons, they usually
        // should have).
        .hasAuthorityComponent = true,
    };
}

int main(int, char** argv)
{
    using namespace Nui;
    using namespace std::string_literals;

    std::filesystem::path programDir = std::filesystem::path(argv[0]).parent_path();

    Window window{
        WindowOptions{
            .title = "NuiScp"s,
            .debug = true,
            .customSchemes = {createFolderMapping(programDir, "liveload"), createFolderMapping(programDir, "assets")},
        },
    };
    RpcHub hub{window};

    ProcessStore processes{window.getExecutor()};
    processes.registerRpc(window, hub);

    // try
    // {
    //     const auto id = processes.emplace(
    //         "D:/msys2/usr/bin/bash.exe",
    //         {"--login", "-i"},
    //         Environment{
    //             false,
    //             {
    //                 {"MSYSTEM", "CLANG64"},
    //                 {"CHERE_INVOKING", "1"},
    //             },
    //             "D:/msys2/usr/bin",
    //         });

    //     auto maybeProcess = processes[id];

    //     maybeProcess->startReading(
    //         [id](std::string_view data) {
    //             std::cout << "Process " << id << " stdout: " << data << std::endl;
    //             return true;
    //         },
    //         [id](std::string_view data) {
    //             std::cout << "Process " << id << " stderr: " << data << std::endl;
    //             return true;
    //         });

    //     maybeProcess->write("ls -lah\rexit\r");

    //     const auto maybeExitCode = maybeProcess->exitSync(10s);
    //     if (maybeExitCode)
    //     {
    //         std::cout << "Process exited with code: " << *maybeExitCode << std::endl;
    //     }
    //     else
    //     {
    //         std::cerr << "No exit code???" << std::endl;
    //         return 1;
    //     }
    // }
    // catch (std::exception const& e)
    // {
    //     std::cerr << "Error: " << e.what() << std::endl;
    //     return 1;
    // }

    // Setup live reload
    // auto removeWatch = setupLiveWatch(hub, programDir);

    window.setSize(1200, 800, Nui::WebViewHint::WEBVIEW_HINT_NONE);
    window.centerOnPrimaryDisplay();
    window.setHtml(index());
    window.run();
}